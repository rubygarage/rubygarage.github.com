<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>RSpec</title>
  <link href="assets/rspec.css" rel="stylesheet">
  <script src="assets/rspec.js"></script>
</head>

<body class="deck-container">

<!-- Begin slides. Just make elements with a class of slide. -->
<section id="topic" class="slide">
  <div class="vcenter">
    <h1>RSpec</h1>
  </div>
</section><section id="value-tests" class="slide">
  <h2>The value of tests</h2>
  <p>
    One of the most valuable benefits of tests is that they give you confidence that your code works as you expect it to work. Tests give you the confidence to do long-term development because with tests in place, you know that your foundation code is dependable. Tests give you the confidence to refactor your code to make it cleaner and more efficient.
  </p>
  <p>
    Tests also save you time because tests help prevent regressions from being introduced and released. Once a bug is found, you can write a test for it, you can fix the bug, and the bug can never make it to production again because the tests will catch it in the future.
  </p>
  <p>
    Another advantage is that tests provide excellent implicit documentation because they show exactly how the code is designed to be used.
  </p>
</section><section id="writing-tests" class="slide">
  <h2>Writing tests</h2>
  <p>
    Let’s take a look at how tests are best structured. All tests should follow the same basic structure.
  </p>
  <div id="set-up-environment" class="slide">
    <h3>1. Set up environment for testing</h3>
    <p>
      Typically, methods perform some sort of operation upon data. So in order to test your methods, you’ll need to set up the data required by the method. This might be as simple as declaring a few variables, or as complex as creating a number of records in database.
    </p>
    <p>
      Your tests should always create their own test data to execute against. That way, you can be confident that your tests aren’t dependent upon the state of a particular environment and will be repeatable even if they are executed in a different environment from which they were written.
    </p>
    <p>
      If you find that many of your tests require very similar setup code, be sure to properly decompose the setup code so that you don’t repeat yourself.
    </p>
  </div>
  <div id="call-method" class="slide">
    <h3>2. Call the method being tested</h3>
    <p>
      Once you have set up the appropriate input data, you still need to execute your code. If you are testing a method, then you will call the method directly.
    </p>
  </div>
  <div id="verify-results" class="slide">
    <h3>3. Verify that the results are correct</h3>
    <p>
      Verifying that your code works as you expect it to work is the most important part of testing. Tests that do not verify the results of the code aren’t true tests. They are commonly referred to as smoke tests, which aren’t nearly as effective or informative as true tests.
    </p>
  </div>
  <div id="clean-up-environment" class="slide">
    <h3>4. Clean up environment</h3>
    <p>
      Environment always should be cleaned after a test running. That way, you can be confident that your next tests are not dependent upon the state of previous tests executing.
    </p>
  </div>
</section><section id="tdd" class="slide">
  <h2>TDD</h2>
  <p>Test Driven Development (TDD) is not about writing tests. TDD is more than that, it’s a methodology. The main idea of TDD is to write tests before code.</p>
  <div id="red" class="slide">
    <h3 class="red">‘Red’ – write failing test</h3>
    <p>
      This means that you have to have a failing test first. You can’t write any production code before ‘red’. Why? Because you have to know this test could fail in some circumstances and you have to know which change makes it pass.
    </p>
  </div>
  <div id="green" class="slide">
    <h3 class="green">‘Green’ – make the test pass</h3>
    <p>
      Write code that is only needed to make the test pass. Now, try to run the test again. WOW, passed! Do you think this is a bad solution? Doesn’t work fine? Sure it works fine, because the test passed. There is YAGNI principal (YAGNI stands for You Ain’t Gonna Need It) which says ‘don’t write more than you need at this moment’. If you are sure you need more, write test for it and then implement this functionality.
    </p>
  </div>
  <div id="refactor" class="slide">
    <h3>‘Refactor’ – clean up your code</h3>
    <p>
      Look at your code. Do you like it? Do you want to eat it? Do you want to f... it? If your answer to any of these questions was ‘no’, you should do something about that. Refactoring is changing code without changing its functionality.
    </p>
  </div>
  <div id="colorful-iteration" class="slide">
    <h3>The colorful iteration</h3>
    <p>
      Whole ‘red, green, refactor’ thing is about iteration, little programming cycles and fast feedback. When we write failing test we say ‘hey, my app should do that!’ Then we make it come true as fast as we can. It’s like in this game where you have to pass the ball to the next player before it ‘burns’ you. When you make a test pass, then you can relax and do refactoring. Change implementation, introduce design pattern and extract class or whatever you want. You have confidence that your code works all the time and that you didn’t break anything. This is the smallest programing cycle; this is exactly what TDD is about.
    </p>
  </div>
</section><section id="installation" class="slide">
  <h2>Installation</h2>
  <h3>Setup envirepment</h3>
  <script type="syntaxhighlighter" class="brush: bash">
    <![CDATA[
    rvm use 1.9.3-head@hello-rspec --create
    Using /Users/sparrow/.rvm/gems/ruby-1.9.3-head with gemset hello-rspec]]>
  </script>
  <h3>Install rspec</h3>
  <script type="syntaxhighlighter" class="brush: bash">
    <![CDATA[
    gem install rspec]]>
  </script>
</section><section id="first-test" class="slide">
  <h2>First test</h2>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
    # file spec/burger_spec.rb

    describe Burger do
      it "should be with ketchup" do
        burger = Burger.new(:ketchup => true)
        burger.should be_with_ketchup
      end

      it "should be without ketchup" do
        burger = Burger.new(:ketchup => false)
        burger.should_not be_with_ketchup
      end
    end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
    <![CDATA[
    rspec spec/burger_spec.rb 
    spec/burger_spec.rb:1:in '<top (required)>': uninitialized constant Object::Burger (NameError)]]>
  </script>
</section><section id="first-implementation" class="slide">
  <h2>First implementation</h2>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
    # file spec/burger_spec.rb
    
    class Burger
      def initialize ingredients = {}
        @ingredients = ingredients
      end

      def with_ketchup?
        @ingredients.has_key?(:ketchup) && !!@ingredients[:ketchup]
      end
    end

    describe Burger do
      it "should be with ketchup" do
        burger = Burger.new(:ketchup => true)
        burger.should be_with_ketchup
      end

      it "should be without ketchup" do
        burger = Burger.new(:ketchup => false)
        burger.should_not be_with_ketchup
      end
    end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
    <![CDATA[
    rspec spec/burger_spec.rb 
    ..

    Finished in 0.0114 seconds
    2 examples, 0 failures]]>
  </script>
</section><section id="describe" class="slide">
  <h2>Describe</h2>
  <p>
    We use the describe() method to define an example group.
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    describe "A User" do
    end
    # => A User 

    describe User do
    end
    # => User 

    describe User, "with no roles assigned" do
    end
    # => User with no roles assigned]]>
  </script>
  <p>
    The describe() method takes an arbitrary number of arguments and an optional block, and returns a subclass of RSpec::Core::ExampleGroup.
  </p>
</section><section id="nested-groups" class="slide">
  <h2>Nested groups</h2>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    describe User
      describe "with no roles assigned" do
        it "is not allowed to view protected content" do
        end  
      end
    end

    # =>  User 
    # =>    with no roles assigned
    # =>      is not allowed to view protected content]]>
  </script>
</section><section id="context" class="slide">
  <h2>Context</h2>
  <p>The context() method is an alias for describe().</p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    describe User
      context "with no roles assigned" do
        it "is not allowed to view protected content" do
        end  
      end
    end

    # =>  User 
    # =>    with no roles assigned
    # =>      is not allowed to view protected content]]>
  </script>
</section><section id="it" class="slide">
  <h2>What’s it() All About?</h2>
  <p>The it() method takes a single String, an optional Hash and an optional block.</p>
  <p>String with 'it' represents the detail that will be expressed in code within the block.</p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file spec/array_spec.rb

    describe Array do
      context "#last" do
        it "should return the last element" do
          array = [:first, :second, :third]
          array.last.should == :third
        end

        it "should not remove the last element" do
          array = [:first, :second, :third]
          array.last
          array.size.should == 3
        end
      end

      context "#pop" do
        it "should return the last element" do
          array = [:first, :second, :third]
          array.pop.should == :third
        end

        it "should remove the last element" do
          array = [:first, :second, :third]
          array.pop
          array.size.should == 2
        end
      end
    end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/array_spec.rb 
    ....

    Finished in 0.00759 seconds
    4 examples, 0 failures]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/array_spec.rb --format documentation

    Array
      #last
        should return the last element
        should not remove the last element
      #pop
        should return the last element
        should remove the last element

    Finished in 0.00212 seconds
    4 examples, 0 failures]]>
  </script>
</section><section id="pending" class="slide">
  <h2>Pending</h2>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  # file spec/array_spec.rb
  
  describe Array do
    context "#last" do
      it "should return the last element" do
        array = [:first, :second, :third]
        pending "bug report #85346"
        array.last.should == :third
      end

      xit "should not remove the last element" do
        array = [:first, :second, :third]
        array.last
        array.size.should == 3
      end
    end
  end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/array_spec.rb --format documentation

    Array
      #last
        should return the last element (PENDING: bug report #85346)
        should not remove the last element (PENDING: Temporarily disabled with xit)

    Pending:
      Array#last should return the last element
        # bug report #85346
        # ./spec/array_spec.rb:42
      Array#last should not remove the last element
        # Temporarily disabled with xit
        # ./spec/array_spec.rb:47

    Finished in 0.0007 seconds
    2 examples, 0 failures, 2 pending]]>
  </script>
</section><section id="hooks" class="slide">
  <h2>Before and after hooks</h2>
  <p>
    Use before and after hooks to execute arbitrary code before and/or after the body of an example is run
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  before(:all)  # run one time only, before all of the examples in a group
  before(:each) # run before each example

  after(:each)  # run after each example
  after(:all)   # run one time only, after all of the examples in a group]]>
  </script>
</section><section id="before-each" class="slide">
  <h2>before(:each)</h2>
  <p>Run before each example</p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  # file spec/array_spec.rb
  
  describe Array, "before each" do
    context "#size" do
      before(:each) do
        @array = Array.new  # We can share object variables (started with '@') between tests
      end

      context "when empty" do
        it "should return zero" do
          @array.size.should == 0
        end

        it "should return one" do
          @array.push 100
          @array.size.should == 1
        end
      end

      context "when full" do
        before(:each) do
          (0...10).each { |n| @array.push n }
        end

        it "should return zero" do
          @array = []
          @array.size.should == 0
        end

        it "should return ten" do
          @array.size.should == 10
        end
      end
    end
  end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
  rspec spec/array_spec.rb 
  ....

  Finished in 0.01025 seconds
  4 examples, 0 failures]]>
  </script>
</section><section id="before-all" class="slide">
  <h2>before(:all)</h2>
  <p>Run one time only, before all of the examples in a group</p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  # file spec/array_spec.rb
  
  describe Array, "before all" do
    context "#size" do
      context "when empty" do
        before(:all) do
          @array = Array.new
        end

        it "should return one" do
          @array.push 100
          @array.size.should == 1
        end

        it "should return one again" do
          @array.size.should == 1
        end
      end

      context "when full" do
        before(:all) do
          @array = Array.new
          (0...10).each { |n| @array.push n }
        end

        it "should return nine" do
          @array.pop
          @array.size.should == 9
        end

        it "should return nine again" do
          @array.size.should == 9
        end
      end
    end
  end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
  rspec spec/array_spec.rb 
  ....

  Finished in 0.01025 seconds
  4 examples, 0 failures]]>
  </script>
</section><section id="hooks-run-in-order" class="slide">
  <h2>Hooks run in order</h2>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  # file spec/callbacks_spec.rb

  describe "before and after callbacks" do
    before(:all) do
      puts "global before all"
    end

    before(:each) do
      puts "global before each"
    end

    after(:each) do
      puts "global after each"
    end

    after(:all) do
      puts "global after all"
    end

    it "gets run in order" do
      puts "global test 1"
    end

    it "gets run in order" do
      puts "global test 2"
    end

    describe "in group" do
      before(:all) do
        puts "group before all"
      end

      before(:each) do
        puts "group before each"
      end

      after(:each) do
        puts "group after each"
      end

      after(:all) do
        puts "group after all"
      end

      it "gets run in order" do
        puts "group test 1"
      end

      it "gets run in order" do
        puts "group test 2"
      end
    end
  end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
  rspec spec/callbacks_spec.rb 
  global before all
  global before each
  global test 1
  global after each
  global before each
  global test 2
  global after each
  group before all
  global before each
  group before each
  group test 1
  group after each
  global after each
  global before each
  group before each
  group test 2
  group after each
  global after each
  group after all
  global after all]]>
  </script>
</section><section id="hooks-in-configuration" class="slide">
  <h2>Define hooks in configuration</h2>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  # file spec/callbacks_spec.rb

  RSpec.configure do |config|
    config.before(:suite) do
      puts "before suite"
    end

    config.before(:all) do
      puts "before all"
    end

    config.before(:each) do
      puts "before each"
    end

    config.after(:each) do
      puts "after each"
    end

    config.after(:all) do
      puts "after all"
    end

    config.after(:suite) do
      puts "after suite"
    end
  end

  describe "before and after callbacks in config" do
    it "run" do
      puts "test 1"
    end

    it "run" do
      puts "test 2"
    end
  end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
  rspec spec/callbacks_spec.rb 
  before suite
  before all
  before each
  test 1
  after each
  before each
  test 2
  after each
  after all
  after suite]]>
  </script>
</section><section id="let" class="slide">
  <h2>Let</h2>
  <p>
    Use <i>let</i> to define a memoized helper method. The value will be cached across multiple calls in the same example but not across examples.
  </p>
  <h3>Use before</h3>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  before do
    @empty_array = Array.new
  end

  it "should be empty" do
    @empty_array.should be_empty
  end]]>
  </script>
  <h3>Use let</h3>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  let(:empty_array) { Array.new }

  it "should be empty" do
    empty_array.should be_empty
  end]]>
  </script>
  <p>
    Note that <i>let</i> is lazy-evaluated: it is not evaluated until the first time the method it defines is invoked. You can use <i>let!</i> to force the method's invocation before each example.
  </p>
</section><section id="subject" class="slide">
  <h2>Subject</h2>
  <p>
    Use subject in the group scope to explicitly define the value that is returned by the subject method in the example scope.
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  # file spec/array_spec.rb

  describe Array, "with some elements" do
    subject { [1,2,3] }

    it { should_not be_empty }

    it "should have the prescribed elements" do
      subject.should == [1,2,3]
    end
  end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
  rspec spec/array_spec.rb --format documentation

  Array with some elements
    should not be empty
    should have the prescribed elements

  Finished in 0.03275 seconds
  2 examples, 0 failures]]>
  </script>
</section><section id="helper-methods" class="slide">
  <h2>Sharing helper methods</h2>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  module UserHelpers
    def valid_user
      User.new(:email => 'email@example.com', :password => 'shhhhh')
    end

    def invalid_user
      User.new(:password => 'shhhhh')
    end
  end

  describe User do
    include UserHelpers

    it "does something when it is valid" do
      user = valid_user
      # do stuff
    end

    it "does something when it is not valid" do
      user = invalid_user
      # do stuff
    end
  end]]>
  </script>
  <h3>Including helper to each test</h3>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  RSpec.configure do |config|
    config.include(UserHelpers)
  end]]>
  </script>
</section><section id="described-class" class="slide">
  <h2>Described class</h2>
  <p>
    If the first argument to the outermost example group is a class, the class is exposed to each example via the described_class() method.
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    describe Fixnum do
      it "is available as described_class" do
        described_class.should == Fixnum
      end
    end]]>
  </script>
</section><section id="shared-examples" class="slide">
  <h2>Shared Examples</h2>
  <p>
    Shared examples let you describe behaviour of types or modules. When declared, a shared group's content is stored. It is only realized in the context of another example group, which provides any context the shared group needs to run.
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  require "set"

  shared_examples "a collection object" do
    describe "<<" do
      it "adds objects to the end of the collection" do
        collection << 1
        collection << 2
        collection.to_a.should eq([1,2])
      end
    end
  end

  describe Array do
    it_behaves_like "a collection object" do
      let(:collection) { Array.new }
    end
  end

  describe Set do
    it_behaves_like "a collection object" do
      let(:collection) { Set.new }
    end
  end]]>
  </script>
  <h3>Including helper to each test</h3>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
  rspec spec/collection_spec.rb --format documentation
  
  Array
    behaves like a collection object
      <<
        adds objects to the end of the collection

  Set
    behaves like a collection object
      <<
        adds objects to the end of the collection

  Finished in 0.00443 seconds
  2 examples, 0 failures]]>
  </script>
</section><section id="shared-context" class="slide">
  <h2>Shared context</h2>
  <p>
    Use shared_context to define a block that will be evaluated in the context of example groups either explicitly, using include_context, or implicitly by matching metadata.
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
  shared_context "shared stuff" do
    before { @some_var = :some_value }

    def shared_method
      "it works"
    end
    
    let(:shared_let) { {'arbitrary' => 'object'} }
    
    subject do
      'this is the subject'
    end
  end

  describe "group that includes a shared context using 'include_context'" do
    include_context "shared stuff"

    it "has access to methods defined in shared context" do
      shared_method.should == "it works"
    end

    it "has access to methods defined with let in shared context" do
      shared_let['arbitrary'].should == "object"
    end

    it "runs the before hooks defined in the shared context" do
      @some_var.should == :some_value
    end

    it "accesses the subject defined in the shared context" do
      should == "this is the subject"
    end
  end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
  rspec spec/shared_stuff_spec.rb 
  ....

  Finished in 0.00758 seconds
  4 examples, 0 failures]]>
  </script>
</section><section id="expectations" class="slide">
  <h2>Expectations</h2>
  <p>
    For checking the expectations, <strong>should()</strong> and <strong>should_not()</strong> methods are used.
  </p>
  <h3>Checking equality and identity</h3>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    cow.should == twin_cow
    cow.should eql(cow)

    cow.should === twin_cow
    cow.should equal(cow)
  ]]>
  </script>
  <p>
    The <strong>==</strong> and <strong>eql</strong> methods are used to express values equivalence, and <strong>===</strong> and <strong>equal</strong> are used when you want the receiver and the argument to be the same object.
  </p>
  <p>
    Note: Instead of using <strong>!=</strong>, you should use the <strong>should_not()</strong> method!
  </p>
</section><section id="how-expectations-work" class="slide">
  <h2>How Expectations work</h2>
  <p>
    Spec::Expectations adds two methods to Object:
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      should(matcher = nil)
      should_not(matcher = nil)
    ]]>
  </script>
  <p>
    Both methods take an optional Expression Matcher.
  </p>
  <p>
    When should receives an Expression Matcher, it calls <i>matches?(self)</i>. If it returns true, the spec passes and execution continues. If it returns false, then the spec fails with the message returned by matcher.failure_message.
  </p>
  <p>
    Similarly, when should_not receives a matcher, it calls <i>matches?(self)</i>. If it returns false, the spec passes and execution continues. If it returns true, then the spec fails with the message returned by matcher.negative_failure_message.
  </p>
</section><section id="matchers" class="slide">
  <h2>Matchers</h2>
  <p>
    RSpec ships with a number of useful Expression Matchers. An Expression Matcher is any object that responds to the following methods:
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      matches?(actual)
      failure_message
      negative_failure_message  # optional
      description               # optional
    ]]>
  </script>
</section><section id="eql" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Eql matcher</h3>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      should eql(expected)
      should_not eql(expected)
    ]]>
  </script>
  <p>
    Passes if given and expected are of equal value, but not necessarily the same object.
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      describe "a string" do
        context "#eq" do
          it "is equal to another string of the same value" do
            "this string".should eq("this string")
          end
        end
        context "#==" do
          it "is equal to another string of the same value" do
            "this string".should == "this string"
          end
        end
      end
    ]]>
  </script>
  <div id="equal" class="slide">
    <h3>Equal matcher</h3>
    <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
        should equal(expected)
        should_not equal(expected)
      ]]>
    </script>
    <p>
      Passes if given and expected are the same object (object identity).
    </p>
    <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
        describe "a string" do
          context "#equal" do
            it "is equal to itself" do
              string = "this string"
              string.should equal(string)
            end
          end
          context "#===" do
            it "is equal to itself" do
              string = "this string"
              string.should === string
            end
          end
        end
      ]]>
    </script>
  </div>
</section><section id="floating-point" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Floating point numbers</h3>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      should be_close(expected, delta)
      should_not be_close(expected, delta)
    ]]>
  </script>
  <p>Passes if given == expected +/- delta</p>
  <p>When dealing with floating points, it's convenient to use matcher be_close(), which takes two arguments: the floating point number you are expecting and the precision you require.</p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      result.should be_close(3.14, 0.005)
    ]]>
  </script>
</section><section id="regexps" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Regular Expressions</h3>
  <p>For checking strings to match regular expressions, the <strong>match</strong> or <strong>=~</strong> is used. This can be very useful when dealing with multiple-line expectations.</p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
   result.should match(/this regexp/)
   result.should =~ /this regexp/
  ]]>
  </script>
</section><section id="predicate_matchers" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Predicate Matchers</h3>
  <p>A Ruby predicate method is a method that ends with a “?” and returns a boolean value, like <strong>string.empty?</strong> or <strong>regexp.match?</strong> methods. For these cases Rspec allows us to describe expectations with <strong>be_something</strong> matcher. When using a be_something matcher, RSpec removes the “be_”, appends a “?” and calls the resulting method in the receiver.</p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
   # instead of writing
   "".empty?.should == true

   # RSpec allows to use predicate expectation
   "".should be_empty
  ]]>
  </script>

  <h6>How it works</h6>
  <ul>
    <li>"be_"        ->      "?"</li>
    <li>"be_zero"    ->      "zero?"</li>
    <li>"be_nil"     ->      "nil?"</li>
    <li>"be_empty"   ->      "empty?"</li>
  </ul>

  <p>
    Alternately, for a predicate method that begins with "has" like Hash#has_key?, RSpec allows you to use an alternate form since "be_has_key" makes no sense.
  </p>
  <ul>
    <li>hash.should have_key(:foo)       ->    calls hash.has_key?(:foo)</li>
    <li>array.should_not have_odd_values   ->    calls array.has_odd_values?</li>
  </ul>

</section><section id="include" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Include</h3>
  <p>
    Passes if given includes expected. This works for collections and Strings. You can also pass in multiple args and it will only pass if all args are found in collection.
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      [1,2,3].should include(3)
      [1,2,3].should include(2,3)
      "spread".should include("read")
      "spread".should_not include("red")
    ]]>
  </script>
  <div id="exist" class="slide">
    <h3>Exist</h3>
    <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      should exist
      should_not exist
    ]]>
    </script>  
    <p>Passes if given.exist?</p>
  </div>
</section><section id="changes" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Changes</h3>
  <p>Sometimens you expect some code (wrapped in a proc) to change the state of some object. There is a convenient way to check it with rspec:</p>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
   it "should remove the last element" do
     lambda {
       @array.pop
     }.should change{ @array.size }
   end
  ]]>
  </script>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
   it "should remove the last element" do
     expect { @array.pop }.to change{ @array.size }
   end
  ]]>
  </script>
  <div id="by-to-from" class="slide">
    <h6>by(), to(), from()</h6>
    <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
     it "should remove the last element" do
       expect { @array.pop }.to change{ @array.size }.by(1)
     end

    it "should remove the last element" do
       expect { @array.pop }.to change{ @array.size }.to(2)
     end

    it "should remove the last element" do
       expect { @array.pop }.to change{ @array.size }.from(3).to(2)
     end
    ]]>
    </script>
  </div>
</section><section id="have" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Have</h3>
  <p>
    RSpec provides several matchers that make it easy to set expectations about the size of a collection. There are three basic forms:
  </p>
  <ul>
    <li>collection.should have(x).items</li>
    <li>collection.should haveatleast(x).items</li>
    <li>collection.should haveatmost(x).items</li>
  </ul>
  <p>
    These work on any collection-like object--the object just needs to respond to #size or #length (or both). When the matcher is called directly on a collection object, the #items call is pure syntactic sugar. You can use anything you want here. These are equivalent:
  </p>
  <ul>
    <li>collection.should have(x).items</li>
    <li>collection.should have(x).things</li>
  </ul>
  <p>
    You can also use this matcher on a non-collection object that returns a collection from one of its methods. For example, Dir#entries returns an array, so you could set an expectation using the following:
  </p>
  <p>Dir.new("my/directory").should have(7).entries</p>
  <h4>A receiver IS a collection </h4>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    describe [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] do
      it { should have(10).items }

      it { should_not have(2).items }

      it { should have_exactly(10).items }
      it { should have_at_least(5).items }
      it { should have_at_most(15).items }
    end
  ]]>
  </script>
  <h4>A receiver OWNS a collection </h4>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    class String
      def words
        self.split(' ')
      end
    end

    describe "a sentence with some words" do
      it { should have(5).words }
      it { should_not have(4).words }

      it { should have_exactly(5).words }
      it { should_not have_exactly(10).words }

      it { should have_at_least(4).words }
      it { should have_at_most(6).words }
    end
  ]]>
  </script>
</section><section id="custom-matchers" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Custom matchers</h3>
  <p>
    When you find that none of the stock Expectation Matchers provide a natural feeling expectation, you can very easily write your own using RSpec’s matcher DSL or writing one from scratch.
  </p>
  <p>
    Imagine that you are writing a game in which players can be in various zones on a virtual board. To specify that bob should be in zone 4, you could say:
  </p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[bob.current_zone.should eql(Zone.new("4"))]]>
  </script>

  <p>But you might find it more expressive to say:</p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[bob.should be_in_zone("4")]]>
  </script>

  <p>You can create such a matcher like so:</p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
    RSpec::Matchers.define :be_in_zone do |zone|
      match do |player|
        player.in_zone?(zone)
      end
    end]]>
  </script>

  <p>Also you can override the failure messages and the generated description:</p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      RSpec::Matchers.define :be_in_zone do |zone|
        match do |player|
          player.in_zone?(zone)
        end
        failure_message_for_should do |player|
          # generate and return the appropriate string.
        end
        failure_message_for_should_not do |player|
          # generate and return the appropriate string.
        end
        description do
          # generate and return the appropriate string.
        end
      end
    ]]>
  </script>
</section><section id="chaining" class="slide">
  <h2>Spec::Matchers</h2>
  <h3>Chaining custom mathcers</h3>
  <p>You can also create matchers that obey a fluent interface using the chain method:</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      RSpec::Matchers.define :tip do |expected_tip|
        chain :on do |bill|
          @bill = bill
        end

        match do |person|
          person.tip_for(@bill) == expected_tip
        end
      end
    ]]>
  </script>

  <p>And now it can be used as follows:</p>
    <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      describe Customer do
        it { should tip(10).on(50) }
      end
    ]]>
  </script>
</section><section id="mocks-and-stubs" class="slide">
  <h2>Mocks, Stubs and doubles</h2>

  <p>A <strong>test double</strong> is an object that stands in for another object in an example.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      thingamajig_double = double('thing-a-ma-jig')
      stub_thingamajig = stub('thing-a-ma-jig')
      mock_thingamajig = mock('thing-a-ma-jig')
    ]]>
  </script>

  <p>The argument is a name, used for failure reporting, so you should use the role that the double is playing in the example.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      def double(*args)
        __declare_double('Double', *args)
      end

      def stub(*args)
        __declare_double('Stub', *args)
      end

      def mock(*args)
        __declare_double('Mock', *args)
      end
    ]]>
  </script>

 <p>Mocks are objects that allow you to set and verify expectations that they will receive specific messages during run time. Stubs provide canned responses to messages they <strong>might</strong> receive in a test, while mocks allow you to specify and, subsquently, verify that certain messages <strong>should</strong> be received during the execution of a test.</p>
</section><section id="as_null_object" class="slide">
  <h2>Mocks, Stubs snd doubles</h2>

  <p>Use the as_null_object method to ignore any messages that aren't explicitly set as stubs or message expectations.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      describe 'null object' do
        specify {
          null_object = double('null object').as_null_object
          other_null = mock('other null', null_object: true)

          null_object.should respond_to(:any_undefined_method)
          other_null.should respond_to(:any_undefined_method)
        }
      end
    ]]>
  </script>
</section><section id="method_stubs" class="slide">
  <h2>Method stubs</h2>

  <p>A <strong>method stub</strong> is a method that we can program to return predefined responses during the execution of a code example.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      describe Statement do
        it "uses the customer's name in the header" do
          customer = double('customer')
          customer.stub(:name).and_return('Aslak')
          statement = Statement.new(customer)
          statement.generate.should =~ /^Statement for Aslak/
        end
      end
    ]]>
  </script>

  <p>Method stubs can return different values on different calls: this will return 5.5% when a message for interest_rate is received <strong>for the first time</strong>, but will return 3% for subsequent calls/messages.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      HomeLoan.stub(interest_rate).and_return('5.5%', '3%')
    ]]>
  </script>

  <p>The mock object can be created with stubbed methods at once.</p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      customer = double('customer', name: 'Aslak')
      obj = mock('object', created_at: { Time.now })
    ]]>
  </script>

  <p>Stub methods can return values depending on the arguments.</p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      ages = double('ages')
      ages.stub(:age_for) do |what|
        if what == 'drinking'
          21
        elsif what == 'voting'
          18
        end
      end
    ]]>
  </script>
</section>

<section id="stub-returns" class="slide">
  <h2>Method stubs</h2>

  <p>Besides returning a value, method stub can yield a block, raise an exception, or throw the message.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      class Triviality
        def one_two_three
          yield self
        end
      end

      triviality.stub(:one_two_three).and_yield(triviality)
      triviality.one_two_three { }
    ]]>
  </script>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      double.stub(:msg).and_raise(NoMethodError)

      double.stub(:msg).and_throw(:msg)
    ]]>
  </script>

</section><section id="unstub" class="slide">
  <h2>unstub (or unstub!)</h2>

  <p>Removes a stub. On a double, the object will no longer respond to message. On a real object, the original method (if it exists) is restored.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      describe String do
        before(:each) { String.stub(:new).and_return("hello") }

        it "can restore it's own behavior" do
          String.new("initial string").should == "hello"
          String.unstub(:new)

          String.new("initial string").should == "initial string"
        end
      end
    ]]>
  </script>

</section><section id="stub-const" class="slide">
  <h2>Stubbing constants</h2>

  <p>Support is provided for stubbing constants. Stubbed constant names must be fully qualified; the current module nesting is not considered.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      module MyGem
        class SomeClass; end
      end

      module MyGem
        describe "Something" do
          it "accidentally stubs the wrong constant" do
            # this stubs ::SomeClass (in the top-level namespace),
            # not MyGem::SomeClass like you probably mean.
            stub_const("SomeClass", Class.new)
          end

          it "stubs the right constant" do
            stub_const("MyGem::SomeClass", Class.new)
          end
        end
      end
    ]]>
  </script>
</section><section id="any-instance" class="slide">
  <h2>Stub on any instance of a class</h2>

  <p>Use any_instance.stub on a class to tell any instance of that class to
return a value (or values) in response to a given message. If no instance
receives the message, nothing happens.</p>

  <p>Messages can be stubbed on any class, including those in Ruby's core library.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      describe "any_instance.stub" do
        it "returns the specified value on any instance of the class" do
          String.any_instance.stub(:foo).and_return(:return_value)

          str = "sample string"
          str.foo.should eq(:return_value)
        end
      end
    ]]>
  </script>

</section><section id="stub-chain" class="slide">
  <h2>Stub a chain of methods</h2>

  <p>The <strong>stub_chain</strong> method lets you to stub a chain of methods in one statement - and there is no need to stub each method in the dependency chain represented by a chain of messages to different objects.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      Article.recent.published.authored_by(params[:author_id])
    ]]>
  </script>
  <br/>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      recent = double()
      published = double()
      authored_by = double()
      article = double()

      Article.stub(:recent).and_return(recent)
      recent.stub(:published).and_return(published)
      published.stub(:authored_by).and_return(article)
    ]]>
  </script>
  <br/>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      article = double()
      Article.stub_chain(:recent, :published, :authored_by).and_return(article)
    ]]>
  </script>
</section><section id="stub_before_all" class="slide">
  <h2>Stubs and before(:all)</h2>

  <h3>Use before(:each), not before(:all)</h3>

  <p>Stubs in before(:all) are not supported. The reason is that all stubs and mocks get cleared out after each example, so any stub that is set in before(:all) would work in the first example that happens to run in that group, but not for any others.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    module RSpec
      module Mocks
        ...
        def teardown
          space.reset_all
        end
        ...
      end
    end

    class Space
      def reset_all
        receivers.each do |mock|
          mock.rspec_reset
        end
        receivers.clear
        expectation_ordering.clear
      end
    end
  ]]>
</script>
</section><section id="should-receive" class="slide">
  <h2>Message expectations</h2>

  <p>A message expectation is an expectation that the test double will receive a message some time before the example ends. If the message is received, the expectation is satisfied. If not, the example fails.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      describe Zipcode do
        context "when created" do
          it "validates a record with provided validator" do
            validator = double("validator")
            validator.should_receive(:validate)

            zipcode = Zipcode.new("02134", validator)
            zipcode.valid?
          end
        end
      end
    ]]>
  </script>

  <p>For a negative expectation, the <strong>should_not_receive</strong> method is provided</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      network_double.stub(:ping).and_return(false)
      network_double.should_not_receive(:open_connection)
    ]]>
  </script>
</section><section id="with" class="slide">
  <h2>Message expectations</h2>
  <h3>Expecting Arguments</h3>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      double.should_receive(:msg).with(*args)
      double.should_not_receive(:msg).with(*args)
    ]]>
  </script>

  <p>Arguments that are passed to with are compared with actual arguments received using ==. In cases in which you want to specify things about the arguments rather than the arguments themselves, you can use any of the matchers that ship with rspec-expectations.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      double.should_receive(:msg).with(no_args())
      double.should_receive(:msg).with(any_args())
      double.should_receive(:msg).with(1, kind_of(Numeric), "b") #2nd argument can be any kind of Numeric
      double.should_receive(:msg).with(1, boolean(), "b") #2nd argument can be true or false
      double.should_receive(:msg).with(1, /abc/, "b") #2nd argument can be any String matching the submitted Regexp
      double.should_receive(:msg).with(1, anything(), "b") #2nd argument can be anything at all
      double.should_receive(:msg).with(1, duck_type(:abs, :div), "b")
                          #2nd argument can be object that responds to #abs and #div
    ]]>
  </script>
</section><section id="receive-counts" class="slide">
  <h2>Message expectations</h2>
  <h3>Receive Counts</h3>

  <p>The implicit expectation is that the message passed to should_receive will be called once. You can make the expected counts explicit using the following</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      double.should_receive(:msg).once
      double.should_receive(:msg).twice
      double.should_receive(:msg).exactly(n).times
      double.should_receive(:msg).at_least(:once)
      double.should_receive(:msg).at_least(:twice)
      double.should_receive(:msg).at_least(n).times
      double.should_receive(:msg).at_most(:once)
      double.should_receive(:msg).at_most(:twice)
      double.should_receive(:msg).at_most(n).times
      double.should_receive(:msg).any_number_of_times
      double.should_receive(:msg).never
    ]]>
  </script>
</section><section id="ordering" class="slide">
  <h2>Message expectations</h2>
  <h3>Ordering</h3>

  <p>When specifying interactions with a test double, the order of the calls is rarely important. In fact, the ideal situation is to specify only a single call. But sometimes, we need to specify that messages are sent in a specific order.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      describe Roster do
        it "asks database for count before adding" do
          database = double()
          student = double()

          database.should_receive(:count).with('Roster', :course_id => 37).ordered
          database.should_receive(:add).with(student).ordered

          roster = Roster.new(37, database)
          roster.register(student)
        end
      end
    ]]>
  </script>

  <p>This example will pass only if the <strong>count( )</strong> and <strong>add( )</strong> messages are sent with the correct arguments and in the same order.</p>
</section><section id="responses" class="slide">
  <h2>Message expectations</h2>
  <h3>Setting responses</h3>

  <p>Whether you are setting a message expectation or a method stub, you can tell the object precisely how to respond. The most generic way is to pass a block to stub or should_receive:</p>

  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      double.should_receive(:msg) { value }
    ]]>
  </script>

  <p>When the double receives the msg message, it evaluates the block and returns the result.</p>

  <p>The same responses are available, as for stub method:</p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      double.should_receive(:msg).and_return(value)
      double.should_receive(:msg).exactly(3).times.and_return(value1, value2, value3)
        # returns value1 the first time, value2 the second, etc
      double.should_receive(:msg).and_raise(error)
        #error can be an instantiated object or a class
        #if it is a class, it must be instantiable with no args
      double.should_receive(:msg).and_throw(:msg)
      double.should_receive(:msg).and_yield(values,to,yield)
      double.should_receive(:msg).and_yield(values,to,yield).and_yield(some,other,values,this,time)
        # for methods that yield to a block multiple times
    ]]>
  </script>

  <p>When working with a partial mock object, you may occasionally want to set a message expecation without interfering with how the object responds to the message. </p>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
      Person.should_receive(:find).and_call_original
      Person.find # => executes the original find method and returns the result
    ]]>
  </script>
</section><section id="example" class="slide">
  <h2>So, let's create an application</h2>
  <h3>Introducing Codebreaker</h3>
  <p>
    Codebreaker is a logic game in which a code-breaker tries to break a secret code created by a code-maker. The code-maker, which will be played by the application we’re going to write, creates a secret code of four numbers between 1 and 6.
  </p>

  <p>
    The code-breaker then gets some number of chances to break the code. In each turn, the code-breaker makes a guess of four numbers. The code-maker then marks the guess with up to four + and - signs.
  </p>

  <p>
    A + indicates an exact match: one of the numbers in the guess is the same as one of the numbers in the secret code and in the same position.
  </p>

  <p>
    A - indicates a number match: one of the numbers in the guess is the same as one of the numbers in the secret code but in a different position.
  </p>
</section><section id="selecting-stories" class="slide">
  <h2>Selecting Stories</h2>

  <p>
    A great way to get started gathering user stories is to do a high-level brain dump of the sorts of things we might like to do. Here are some titles to get started:
  </p>

  <ul>
    <li><strong>Code-breaker starts game</strong>
      <p>The code-breaker opens a shell, types a command, and sees a welcome message and a prompt to enter
the first guess.</p>
    </li>
    <li><strong>Code-breaker submits guess</strong>
      <p>The code-breaker enters a guess, and the system replies by marking the guess according to the marking algorithm.
      </p></li>
    <li><strong>Code-breaker wins game</strong>
      <p>
       The code-breaker enters a guess that matches the secret code exactly. The system responds by marking the guess with four + signs and a message congratulating the code-breaker on breaking the code in however many guesses it took.
      </p></li>
    <li><strong>Code-breaker loses game</strong>
      <p>
        After some number of turns, the game tells the code-breaker that the game is over (need to decide how many turns and whether to reveal the code).
      </p></li>
    <li><strong>Code-breaker plays again</strong>
      <p>
        After the game is won or lost, the system prompts the code-breaker to play again. If the code-breaker indicates yes, a new game begins. If the code-breaker indicates no, the system shuts down.
      </p></li>
    <li><strong>Code-breaker requests hint</strong>
      <p>
        At any time during a game, the code-breaker can request a hint, at which point the system reveals one of the numbers in the secret code.
      </p></li>
    <li><strong>Code-breaker saves score</strong>
      <p>
        After the game is won or lost, the code-breaker can opt to save information about the game: who (initials?), how many turns, and so on.
      </p></li>
  </ul>
</section><section id="codebreaker-gem" class="slide">
  <h2>Creating codebreaker gem</h2>
  <script type="syntaxhighlighter" class="brush: bash">
    <![CDATA[
    rvm use 1.9.3-head@codebreaker --create
    Using /Users/sparrow/.rvm/gems/ruby-1.9.3-head with gemset codebreaker]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
    <![CDATA[
    gem install bundler]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
    <![CDATA[
    bundle gem codebreaker]]>
  </script>
  <script type="syntaxhighlighter" class="brush: ruby">
    <![CDATA[
    # file codebreaker.gemspec

    # ...
    Gem::Specification.new do |gem|
      # ...
    
      gem.add_development_dependency "rspec"
    end]]>
  </script>
  <script type="syntaxhighlighter" class="brush: bash">
    <![CDATA[
    bundle install]]>
  </script>
</section><section id="first-spec" class="slide">
  <h2>Describing Code with RSpec</h2>

  <p>Now we're going to describe the expected behavior of instances of the Game class.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file spec/spec_helper.rb

    require 'bundler/setup'
    require 'codebreaker'
  ]]>
  </script>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file spec/codebreaker/game_spec.rb

    require 'spec_helper'

    module Codebreaker
      describe Game do
        describe "#start" do
          it "sends a welcome message"
          it "prompts for the first guess"
        end
      end
    end]]>
  </script>

  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/codebreaker/game_spec.rb --format doc

    /home/alony/projects/rspec-example/spec/codebreaker/game_spec.rb:4:in '<module:Codebreaker>': 
      uninitialized constant Codebreaker::Game (NameError)
    from /home/alony/projects/rspec-example/spec/codebreaker/game_spec.rb:3:in '<top (required)>'
    from /home/alony/.rvm/gems/ruby-1.9.2-p320/gems/rspec-core-2.11.1/lib/rspec/core/configuration.rb:780:in 'load'
    ...]]>
  </script>
</section><section id="addig-code" class="slide">
  <h2>Describing Code with RSpec</h2>

  <p>So let's add some code structure</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file lib/codebreaker.rb

    require 'codebreaker/game']]>
  </script>
  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file lib/codebreaker/game.rb

    module Codebreaker
      class Game
        def start
        end
      end
    end
  ]]>
  </script>

  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/codebreaker/game_spec.rb --format doc

    Codebreaker::Game
      #start
        sends a welcome message (PENDING: Not yet implemented)
        prompts for the first guess (PENDING: Not yet implemented)

    Pending:
      Codebreaker::Game#start sends a welcome message
        # Not yet implemented
        # ./spec/codebreaker/game_spec.rb:6
      Codebreaker::Game#start prompts for the first guess
        # Not yet implemented
        # ./spec/codebreaker/game_spec.rb:7

  ]]>
  </script>
</section><section id="failing-spec" class="slide">
  <h2>Red: Start with a Failing Code Example</h2>

  <p>In game_spec.rb, we want to specify that when we start the game, it sends the right messages to the output.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file spec/codebreaker/game_spec.rb

    require 'spec_helper'

    module Codebreaker
      describe Game do
        describe "#start" do
          it "sends a welcome message" do
            output = double('output')
            game = Game.new(output)
            output.should_receive(:puts).with('Welcome to Codebreaker!')
            game.start
          end
          it "prompts for the first guess"
        end
      end
    end]]>
  </script>

  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/codebreaker/game_spec.rb --format doc

    Codebreaker::Game
      #start
        sends a welcome message (FAILED - 1)
        prompts for the first guess (PENDING: Not yet implemented)

    Pending:
      Codebreaker::Game#start prompts for the first guess
        # Not yet implemented
        # ./spec/codebreaker/game_spec.rb:12

    Failures:

      1) Codebreaker::Game#start sends a welcome message
         Failure/Error: output.should_receive(:puts).with('Welcome to Codebreaker!')
           (Double "output").puts("Welcome to Codebreaker!")
               expected: 1 time
               received: 0 times
         # ./spec/codebreaker/game_spec.rb:9:in 'block (3 levels) in <module:Codebreaker>'
  ]]>
  </script>
</section><section id="passing-spec" class="slide">
  <h2>Green: Get the Example to Pass</h2>

  <p>The failure message tells us that output never received puts. Here’s what we need to do to get this example to pass:</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file lib/codebreaker/game.rb

    module Codebreaker
      class Game
        def initialize(output)
          @output = output
        end

        def start
          @output.puts 'Welcome to Codebreaker!'
        end
      end
    end
  ]]>
  </script>

  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/codebreaker/game_spec.rb --format doc

    Codebreaker::Game
      #start
        sends a welcome message
        prompts for the first guess (PENDING: Not yet implemented)

    Pending:
      Codebreaker::Game#start prompts for the first guess
        # Not yet implemented
        # ./spec/codebreaker/game_spec.rb:12

    Finished in 0.00071 seconds
    2 examples, 0 failures, 1 pending

  ]]>
  </script>
</section><section id="next-step" class="slide">
  <h2>Next step</h2>

  <p>The following failing step is the next thing to work on: <strong>And I should see "Enter guess:"</strong>.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file spec/codebreaker/game_spec.rb

    require 'spec_helper'

    module Codebreaker
      describe Game do
        describe "#start" do
          it "sends a welcome message" do
            ...
          end

          it "prompts for the first guess" do
            output = double('output')
            game = Game.new(output)
            output.should_receive(:puts).with('Enter guess:')
            game.start
          end
        end
      end
    end
  ]]>
  </script>

  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/codebreaker/game_spec.rb --format doc

    Codebreaker::Game
      #start
        sends a welcome message
        prompts for the first guess (FAILED - 1)

    Failures:

      1) Codebreaker::Game#start prompts for the first guess
         Failure/Error: game.start
           Double "output" received :puts with unexpected arguments
             expected: ("Enter guess:")
                  got: ("Welcome to Codebreaker!")
         # ./lib/codebreaker/game.rb:8:in 'start'
         # ./spec/codebreaker/game_spec.rb:16:in 'block (3 levels) in <module:Codebreaker>'

   Finished in 0.00126 seconds
   2 examples, 1 failure]]>
  </script>
</section><section id="resolve-step" class="slide">
  <h2>Trying to get green again</h2>

  <p>This time, the output didn’t receive puts('Enter guess:'). Resolve that as follows:</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file lib/codebreaker/game.rb

    module Codebreaker
      class Game
        def initialize(output)
          @output = output
        end

        def start
          @output.puts 'Welcome to Codebreaker!'
          @output.puts 'Enter guess:'
        end
      end
    end
  ]]>
  </script>

  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/codebreaker/game_spec.rb --format doc

    Codebreaker::Game
      #start
        sends a welcome message (FAILED - 1)
        prompts for the first guess (FAILED - 2)

    Failures:

      1) Codebreaker::Game#start sends a welcome message
         Failure/Error: game.start
           Double "output" received :puts with unexpected arguments
             expected: ("Welcome to Codebreaker!")
                  got: ("Enter guess:")
         # ./lib/codebreaker/game.rb:9:in `start'
         # ./spec/codebreaker/game_spec.rb:10:in `block (3 levels) in <module:Codebreaker>'

      2) Codebreaker::Game#start prompts for the first guess
         Failure/Error: game.start
           Double "output" received :puts with unexpected arguments
             expected: ("Enter guess:")
                  got: ("Welcome to Codebreaker!")
         # ./lib/codebreaker/game.rb:8:in `start'
         # ./spec/codebreaker/game_spec.rb:16:in `block (3 levels) in <module:Codebreaker>'

    Finished in 0.00136 seconds
    2 examples, 2 failures
  ]]>
  </script>
</section><section id="fix-step" class="slide">
  <h2>Fix things up</h2>

  <p>We’ve told the double in the first example to expect puts( ) with “Welcome to Codebreaker!” and we’ve satisfied that requirement, but we’ve only
told it to expect “Welcome to Codebreaker!” It doesn’t know anything about “Enter guess:”</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file spec/codebreaker/game_spec.rb

	module Codebreaker
	  describe Game do
	    describe "#start" do
	      it "sends a welcome message" do
	        output = double('output').as_null_object
	        game = Game.new(output)
	        output.should_receive(:puts).with('Welcome to Codebreaker!')
	        game.start
	      end

	      it "prompts for the first guess" do
			output = double('output').as_null_object
			game = Game.new(output)
			output.should_receive(:puts).with('Enter guess:')
			game.start
	      end
	    end
	  end
	end
  ]]>
  </script>

  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/codebreaker/game_spec.rb --format doc

	Codebreaker::Game
	  #start
	    sends a welcome message
	    prompts for the first guess

	Finished in 0.00103 seconds
	2 examples, 0 failures

  ]]>
  </script>
</section><section id="refactor" class="slide">
  <h2>Refactor</h2>

  <p>"Refactoring is the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure."</p>

  <p>In this case, we have a very clear break between what is context and what is behavior, so let’s take advantage of that and move the context to a block that is executed before each of the examples.</p>

  <script type="syntaxhighlighter" class="brush: ruby">
  <![CDATA[
    # file spec/codebreaker/game_spec.rb

    module Codebreaker
      describe Game do
        describe "#start" do
          let(:output) { double('output').as_null_object }
          let(:game)   { Game.new(output) }

          it "sends a welcome message" do
            output.should_receive(:puts).with('Welcome to Codebreaker!')
            game.start
          end

          it "prompts for the first guess" do
            output.should_receive(:puts).with('Enter guess:')
            game.start
          end
        end
      end
    end
  ]]>
  </script>

  <script type="syntaxhighlighter" class="brush: bash">
  <![CDATA[
    rspec spec/codebreaker/game_spec.rb --format doc

    Codebreaker::Game
      #start
        sends a welcome message
        prompts for the first guess

    Finished in 0.00105 seconds
    2 examples, 0 failures
  ]]>
  </script>
</section><!-- End slides. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
  <span class="deck-status-current"></span>
  /
  <span class="deck-status-total"></span>
</p>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

</body>
</html>

